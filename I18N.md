# Internationalization (i18n)

This plugin supports multiple languages. Currently supported languages:
- **English** (default)
- **Japanese**

## How it Works

The plugin automatically detects the language from Obsidian's settings and displays the UI in the appropriate language. The language detection is based on Obsidian's `moment.locale()` which reflects the user's language preference.

## Adding a New Language

To add support for a new language, follow these steps:

### 1. Create a Translation File

Create a new file in the `locales` directory named after the language code (e.g., `fr.ts` for French, `de.ts` for German):

```typescript
/**
 * [Language] translations
 */
export const [language_code] = {
	// Copy all keys from locales/en.ts
	// Translate the values to your language
	modal_title: 'Your translation here',
	modal_description: 'Your translation here',
	// ... all other keys
};
```

### 2. Update i18n.ts

Add your language to the translations object in `i18n.ts`:

```typescript
import { [language_code] } from './locales/[language_code]';

const translations: Record<string, Translations> = {
	en,
	ja,
	[language_code], // Add your language here
};
```

### 3. Update Language Detection

Update the `getCurrentLocale()` function in `i18n.ts` to detect your language:

```typescript
export function getCurrentLocale(): string {
	const obsidianLocale = moment.locale();
	
	if (obsidianLocale.startsWith('ja')) {
		return 'ja';
	}
	
	// Add your language detection here
	if (obsidianLocale.startsWith('[language_code]')) {
		return '[language_code]';
	}
	
	// Default to English
	return 'en';
}
```

### 4. Test Your Translation

1. Build the plugin: `npm run build`
2. Change Obsidian's language to your target language
3. Test all UI elements to ensure translations are correct

## Translation Keys

All translation keys are defined in `locales/en.ts`. Each key must be present in all language files. The keys are organized by category:

- **Modal**: UI elements in the URL input modal
- **Notices**: Notification messages
- **Errors**: Error messages
- **Commands**: Command palette entries
- **Ribbon**: Ribbon icon tooltips
- **Settings**: Settings page labels and descriptions
- **Sample template**: Default template content
- **Template metadata keys**: Metadata field names for templates

## Testing Translations

To verify that your translations are complete and consistent:

```bash
node << 'EOF'
const fs = require('fs');
const path = require('path');

const enPath = path.join(process.cwd(), 'locales', 'en.ts');
const yourLangPath = path.join(process.cwd(), 'locales', '[language_code].ts');

const extractKeys = (content) => {
  const matches = content.match(/^\s+(\w+):/gm) || [];
  return matches.map(m => m.trim().replace(':', ''));
};

const enKeys = new Set(extractKeys(fs.readFileSync(enPath, 'utf-8')));
const yourLangKeys = new Set(extractKeys(fs.readFileSync(yourLangPath, 'utf-8')));

enKeys.forEach(key => {
  if (!yourLangKeys.has(key)) {
    console.error(`Missing in your language: ${key}`);
  }
});

yourLangKeys.forEach(key => {
  if (!enKeys.has(key)) {
    console.error(`Extra key in your language: ${key}`);
  }
});

console.log('Check complete!');
EOF
```

## Notes

- Always use the English translation file (`locales/en.ts`) as the reference for all keys
- Keep all translation files in sync - every key in English must exist in all other languages
- Use placeholder syntax `{{variable}}` for dynamic content (e.g., `{{filename}}`, `{{message}}`)
- The sample template can have different metadata field names per language (e.g., "Title" in English, "タイトル" in Japanese)
